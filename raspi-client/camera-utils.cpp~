#include "camera-utils.hpp"

/****   D E F I N E    S E C T I O N   *******/
//* For the Camera 

//* For the TCP/IP Conection
#define PORT 5050
#define SA struct sockaddr 
#define MAX_UDP_PACK 65000

//* For the Queue
#define QUEUE_MAX_FRAMES   30

//* For Threads
#define BACKGROUND_AVERAGE 30
#define THRESHOLD_PX       5
#define THRESHOLD_SEND     5

/**** G L O B A L    V A R I A B L E S *******/
extern queue<Mat> q_capture;
extern queue<Mat> q_send;

extern pthread_mutex_t m;
extern pthread_mutex_t m_send;

extern int items;
extern int items_send;


/*****  T I M I N G    F U N C T I O N  *****/
void timerStart(timeval *t_start) {
  gettimeofday(t_start, NULL);
}


void timerStop(timeval *t_stop) {
  gettimeofday(t_stop, NULL);
}


double getTime(timeval t_start, timeval t_stop) {
  return   ((t_stop.tv_sec - t_start.tv_sec) + ((t_stop.tv_usec - t_start.tv_usec)/1000000.0));
}


/*****  Q U E U E    F U N C T I O N  *****/
void insert_capture(Mat img) {
  pthread_mutex_lock(&m);
  if (items < QUEUE_MAX_FRAMES) {
    q_capture.push(img);
    items++;
  }
  pthread_mutex_unlock(&m);
}

Mat pop_capture() {
  Mat img;

  while (img.empty()) {
    pthread_mutex_lock(&m);
    if (items > 0) {
      img = q_capture.front();
      q_capture.pop();
      items--;
    } 
    pthread_mutex_unlock(&m);
  }
  
  return img;  
}

void insert_send(Mat img) {
  pthread_mutex_lock(&m_send);
  if (items < QUEUE_MAX_FRAMES) {
    q_send.push(img);
    items_send++;
  }
  pthread_mutex_unlock(&m_send);
}

Mat pop_send() {
  Mat img;

  while (img.empty()) {
    pthread_mutex_lock(&m_send);
    if (items_send > 0) {
      img = q_send.front();
      q_send.pop();
      items_send--;
    } 
    pthread_mutex_unlock(&m_send);
  }
  
  return img;  
}


/*****  I M A G E    F U N C T I O N  *****/
unsigned char *newImageVectorPack(Mat img, unsigned int *max_buf) {
  //==== Vector Size and Bits Data Position: =====//
  //   2 bytes (rows)     +                       //
  //   2 bytes (columns)  +                       //
  //   1 byte  (channels) +                       //
  //   1 byte  (depth)    +                       //
  //   n bytes (Pixels Rows x Columns x Channels) //
  //==============================================//
  short rows             = img.rows;
  short cols             = img.cols;
  unsigned char channels = img.channels();
  unsigned char depth    = img.type() & CV_MAT_DEPTH_MASK;

  //Buffer New
  *max_buf = (rows * cols * channels) + 6;
  unsigned char *v_colors = new unsigned char[*max_buf];
  unsigned char *v_colors_tmp;
  
  v_colors_tmp = v_colors;

  //Copy the image parameters into the vector 
  memcpy(v_colors_tmp, &rows, sizeof rows);
  v_colors_tmp += (sizeof rows);
  
  memcpy(v_colors_tmp, &cols, sizeof cols);
  v_colors_tmp += (sizeof cols);

  memcpy(v_colors_tmp, &channels, sizeof channels);
  v_colors_tmp += (sizeof channels);

  memcpy(v_colors_tmp, &depth, sizeof depth);
  v_colors_tmp += (sizeof depth);

  //Copy the image into the vector
  unsigned int v_index = 0;
  if (channels == 3) {
    //Image with three channels
    for (short i = 0; i < rows; i++) {
      for (short j = 0; j < cols; j++) {
    	for (unsigned char c = 0; c < channels; c++) {
    	  v_colors_tmp[v_index++] = (unsigned char)img.at<Vec3b>(i,j)[c];
    	}
      }
    }
  } else {
    //Image with one channel
    for (short i = 0; i < rows; i++) {
      for (short j = 0; j < cols; j++) {
	v_colors_tmp[v_index++] = (unsigned char)img.at<uchar>(i,j);
      }
    }  
  }

  return v_colors;

}

//Calculate  Average Background
Mat calculateBackground(unsigned int average) {
  unsigned int n_average = 0;
  Mat img, background;
  Mat acum_blue, acum_green, acum_red;
  
  while(n_average < average) {    
    img = pop_capture();
    
    if (n_average == 0) {
      background = img.clone();
      acum_blue  = Mat(img.rows, img.cols, CV_32F);
      acum_green = Mat(img.rows, img.cols, CV_32F);
      acum_red   = Mat(img.rows, img.cols, CV_32F);
    }
    
    for (int i = 0; i < img.rows; i++) {
      for (int j = 0; j < img.cols; j++) {
	acum_blue.at<float>(i,j) += (float)img.at<Vec3b>(i,j)[0];
	acum_green.at<float>(i,j)+= (float)img.at<Vec3b>(i,j)[1];
	acum_red.at<float>(i,j)  += (float)img.at<Vec3b>(i,j)[2];
      }
    }      	
    n_average++;
    img.release();
  }
  
  //Values Average
  for (int i = 0; i < img.rows; i++) {
    for (int j = 0; j < img.cols; j++) {
      background.at<Vec3b>(i, j)[0] = (unsigned char)(acum_blue.at<float>(i,j) / n_average);
      background.at<Vec3b>(i, j)[1] = (unsigned char)(acum_green.at<float>(i,j) / n_average);
      background.at<Vec3b>(i, j)[2] = (unsigned char)(acum_red.at<float>(i,j) / n_average);
    }
  }

  acum_blue.release();
  acum_green.release();
  acum_red.release();
  
  return background;  
}

float differenceRatioBackground(Mat background, Mat img, float threshold_pixel) {
  int different_px = 0;
  int max_distance = 256 + 256 + 256; // Red + Green + Blue
  
  //Different pixels between the new image "img" and the background "background"
  for (int i = 0; i < background.rows; i++) {
    for (int j = 0; j < background.cols; j++) {
      Vec3b pixels_a = img.at<Vec3b>(i, j);
      Vec3b pixels_b = background.at<Vec3b>(i, j);
      unsigned int distance = abs(pixels_a[0] - pixels_b[0]) + 
	abs(pixels_a[1] - pixels_b[1]) +
	abs(pixels_a[2] - pixels_b[2]);
      float distance_ratio  = (distance * 100) / max_distance;
      if (distance_ratio > threshold_pixel)
	different_px += 1;
    }
  }      

  //Calculate and return the difference ratio 
  return ((different_px * 100) / (background.rows * background.cols));
}


/*****  T H R E A D S    F U N C T I O N  *****/

//= C A P T U R E    F R A M E S =//
void *getFrame(void *input) {

  VideoCapture cap(0); //VideoCapture From 0
  Mat img;
  
  if(!cap.isOpened()) {
    std::cout << "[ERROR] I can't open the camera. Exit." << std::endl;
    exit(-1);
  }
  
  //Image Size Fixed
  cap.set(cv::CAP_PROP_FRAME_WIDTH,  640);
  cap.set(cv::CAP_PROP_FRAME_HEIGHT, 480);
  
  while (true) {
    cap >> img;
    insert_capture(img.clone());
  }

  return NULL; 
}


//= P R O C E S S    F R A M E S =//
void *processFrame(void *input) {
  Mat img, background;
  
  background = calculateBackground(BACKGROUND_AVERAGE);
  //imshow("img", background);waitKey(0);
  
  while(true) {
    img = pop_capture();
    float threshold = differenceRatioBackground(background, img, THRESHOLD_PX);
    std::cout << "[INFO] Threshold-Ratio: " << threshold << ", Threshold-Limit: " << THRESHOLD_SEND << std::endl;
    if (threshold > THRESHOLD_SEND)
      insert_send(img);
    else
      img.release();
  }
  
  return NULL;  
}


//= S E N D    F R A M E S =// 
void *sendFrame(void *input) {
  
  int sockfd; 
  struct sockaddr_in servaddr;
  
  // socket create and varification 
  sockfd = socket(AF_INET, SOCK_STREAM, 0); 
  if (sockfd == -1) { 
    std::cout << "[ERROR] Socket creation failed" << std::endl;
    exit(-1); 
  } 
  
  bzero(&servaddr, sizeof(servaddr));   
  servaddr.sin_family = AF_INET;   
  servaddr.sin_addr.s_addr = inet_addr("127.0.0.1"); //Mi PC
  servaddr.sin_port = htons(PORT); 
  
  // connect the client socket to server socket 
  if (connect(sockfd, (SA*)&servaddr, sizeof(servaddr)) != 0) {
    std::cout << "[ERROR] Connection with the server failed" << std::endl;
    exit(-1); 
  } 

  Mat img;
  unsigned int max_buff;
  unsigned char *imgPackBuff;
  
  while(true) {
    img = pop_send();
    imgPackBuff = newImageVectorPack(img, &max_buff);
    size_t b = write(sockfd, imgPackBuff, max_buff);
    if (b == 0)
      std::cout << "[WARNING] No data writed to the server." << std::endl;
    free(imgPackBuff);
    img.release();
  }
  
  close(sockfd);
  
  return NULL;
}

